/*! For license information please see pluglight.min.js.LICENSE.txt */
(()=>{"use strict";var __webpack_modules__={"./src/CollectionManager.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }\nvar _collections = /*#__PURE__*/new WeakMap();\nvar CollectionManager = /*#__PURE__*/function () {\n  function CollectionManager(world) {\n    _classCallCheck(this, CollectionManager);\n    _classPrivateFieldInitSpec(this, _collections, {\n      writable: true,\n      value: void 0\n    });\n    this.world = world;\n    _classPrivateFieldSet(this, _collections, {});\n    this.toBeRemoved = [];\n    this._objectPool = []; // Only for internal use\n  }\n  _createClass(CollectionManager, [{\n    key: "registerCollection",\n    value: function registerCollection(name) {\n      // Defensive input check\n\n      if (typeof name !== \'string\' || name == \'\') {\n        console.error("Cannot register collection with a name defined as: ".concat(typeName, "; the name must be a non-empty string"));\n        return false;\n      }\n      if (_classPrivateFieldGet(this, _collections)[name]) {\n        console.error("Collection named \'".concat(name, "\' already registered"));\n        return false;\n      }\n\n      //\n\n      _classPrivateFieldGet(this, _collections)[name] = [];\n      return this;\n      collection;\n    }\n  }, {\n    key: "getCollection",\n    value: function getCollection(collectionName) {\n      if (_classPrivateFieldGet(this, _collections)[collectionName]) {\n        return _classPrivateFieldGet(this, _collections)[collectionName];\n      }\n      console.error("Cannot get unregistered collection \'".concat(collectionName, "\'"));\n      return false;\n    }\n  }, {\n    key: "addToCollection",\n    value: function addToCollection(collectionName) {\n      var object = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      // Defensive input check \n\n      if (!_classPrivateFieldGet(this, _collections)[collectionName]) {\n        console.error("collection named \'".concat(collectionName, " is not registered\'"));\n        return false;\n      }\n      if (_typeof(object) != \'object\' || !object.isInCollection || !object.addCollection) {\n        console.error("The value passed as \'entity\' is not a valid Entity object ".concat(collectionName));\n        return false;\n      }\n      if (object.isInCollection && object.isInCollection(collectionName)) {\n        console.error("The entity is already registered to collection ".concat(collectionName));\n        return false;\n      }\n\n      //\n\n      _classPrivateFieldGet(this, _collections)[collectionName].push(object);\n      object.addCollection(collectionName);\n      return true;\n    }\n  }, {\n    key: "cacheToBeRemoved",\n    value: function cacheToBeRemoved(collectionName, entity) {\n      var data;\n      if (this._objectPool.length > 0) {\n        data = this._objectPool.pop();\n        data.collectionName = collectionName;\n        data.entity = entity;\n        this.toBeRemoved.push(data);\n      } else {\n        this.toBeRemoved.push({\n          collectionName: collectionName,\n          entity: entity\n        });\n      }\n    }\n  }, {\n    key: "removeFromCollection",\n    value: function removeFromCollection(collectionName, object) {\n      var index = _classPrivateFieldGet(this, _collections)[collectionName].indexOf(object);\n      _classPrivateFieldGet(this, _collections)[collectionName].splice(index, 1);\n      object.removeCollection(collectionName);\n    }\n  }, {\n    key: "removeAgentsFromCollections",\n    value: function removeAgentsFromCollections() {\n      while (this.toBeRemoved.length > 0) {\n        var command = this.toBeRemoved.pop();\n        this.removeFromCollection(command.collectionName, command.entity);\n        command.collectionName = undefined;\n        command.entity = undefined;\n        this._objectPool.push(command);\n      }\n    }\n  }]);\n  return CollectionManager;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CollectionManager);\n\n//# sourceURL=webpack://cases/./src/CollectionManager.js?')},"./src/Entity.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }\nvar _type = /*#__PURE__*/new WeakMap();\nvar _collections = /*#__PURE__*/new WeakMap();\nvar _ID = /*#__PURE__*/new WeakMap();\nvar Entity = /*#__PURE__*/function () {\n  function Entity(typeName, prototype, ID) {\n    var _this = this;\n    _classCallCheck(this, Entity);\n    _classPrivateFieldInitSpec(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _collections, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _ID, {\n      writable: true,\n      value: void 0\n    });\n    this._children = {};\n    _classPrivateFieldSet(this, _collections, {});\n    _classPrivateFieldSet(this, _type, typeName);\n    _classPrivateFieldSet(this, _ID, ID);\n    if (!prototype[\'info\']) return;\n    Object.keys(prototype[\'info\']).forEach(function (field) {\n      var _field = prototype[\'info\'][field];\n      if (_typeof(_field) == \'object\') _this[field] = Object.assign({}, _field);else _this[field] = _field;\n    });\n  }\n  _createClass(Entity, [{\n    key: "getID",\n    value: function getID() {\n      return _classPrivateFieldGet(this, _ID);\n    }\n  }, {\n    key: "getType",\n    value: function getType() {\n      return _classPrivateFieldGet(this, _type);\n    }\n  }, {\n    key: "isInCollection",\n    value: function isInCollection(collectionName) {\n      return _classPrivateFieldGet(this, _collections)[collectionName];\n    }\n  }, {\n    key: "getCollections",\n    value: function getCollections() {\n      return Object.keys(_classPrivateFieldGet(this, _collections));\n    }\n  }, {\n    key: "addCollection",\n    value: function addCollection(collectionName) {\n      _classPrivateFieldGet(this, _collections)[collectionName] = 1;\n    }\n  }, {\n    key: "removeCollection",\n    value: function removeCollection(collectionName) {\n      delete _classPrivateFieldGet(this, _collections)[collectionName];\n    }\n  }, {\n    key: "reset",\n    value: function reset(prototype, newID) {\n      var _this2 = this;\n      _classPrivateFieldSet(this, _ID, newID);\n      Object.keys(prototype[\'info\']).forEach(function (field) {\n        var _field = prototype[\'info\'][field];\n        if (_typeof(_field) == \'object\') _this2[field] = Object.assign({}, _field);else _this2[field] = _field;\n      });\n    }\n  }]);\n  return Entity;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Entity);\n\n//# sourceURL=webpack://cases/./src/Entity.js?')},"./src/EntityPool.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity.js */ "./src/Entity.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }\n\nvar _types = /*#__PURE__*/new WeakMap();\nvar _pools = /*#__PURE__*/new WeakMap();\nvar _Entity = /*#__PURE__*/new WeakMap();\nvar _nextID = /*#__PURE__*/new WeakMap();\nvar EntityPool = /*#__PURE__*/function () {\n  function EntityPool(world) {\n    _classCallCheck(this, EntityPool);\n    _classPrivateFieldInitSpec(this, _types, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _pools, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _Entity, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _nextID, {\n      writable: true,\n      value: void 0\n    });\n    this.world = world;\n    _classPrivateFieldSet(this, _types, {}); // Type Object Pattern\n    _classPrivateFieldSet(this, _pools, {}); // Object Pool Pattern\n    this.toBeRemoved = [];\n    _classPrivateFieldSet(this, _nextID, 0);\n    _classPrivateFieldSet(this, _Entity, _Entity_js__WEBPACK_IMPORTED_MODULE_0__["default"]);\n  }\n  _createClass(EntityPool, [{\n    key: "registerType",\n    value: function registerType(typeName, prototype) {\n      // Defensive input check\n\n      if (typeof typeName !== \'string\' || typeName == \'\') {\n        console.error("Cannot create agentType with a type name defined as: ".concat(typeName, "; the type must be a non-empty string"));\n        return false;\n      }\n      if (_classPrivateFieldGet(this, _types)[typeName] != undefined) {\n        console.error("The type named \'".concat(typeName, "\' has already been registered"));\n        return false;\n      }\n      if (prototype == undefined) {\n        console.error(\'Prototype cannot be undefined, it must be a JSON with the attributes of the entity\');\n        return false;\n      }\n\n      //\n\n      _classPrivateFieldGet(this, _types)[typeName] = prototype;\n      _classPrivateFieldGet(this, _pools)[typeName] = [];\n      return true;\n    }\n  }, {\n    key: "createAgent",\n    value: function createAgent(typeName) {\n      var details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      // Defensive input check\n\n      if (typeof typeName !== \'string\' || typeName == \'\') {\n        console.error("Cannot create entity with a type defined as: ".concat(typeName, "; the type must be a non-empty string"));\n        return false;\n      }\n      if (!_classPrivateFieldGet(this, _types)[typeName]) {\n        console.error("Cannot create entity with a type defined as: ".concat(typeName, "; the type doesn\'t exist at EntityPool"));\n        return false;\n      }\n      if (details != undefined && _typeof(details) !== \'object\') {\n        console.error("\'details\' must be an object");\n        return false;\n      }\n\n      //\n\n      var world = this.world;\n      var entity;\n      if (_classPrivateFieldGet(this, _pools)[typeName].length > 0) {\n        entity = _classPrivateFieldGet(this, _pools)[typeName].pop();\n        this.resetAgent(entity);\n      } else {\n        var _this$nextID, _this$nextID2;\n        entity = new (_classPrivateFieldGet(this, _Entity))(typeName, _classPrivateFieldGet(this, _types)[typeName], (_classPrivateFieldSet(this, _nextID, (_this$nextID = _classPrivateFieldGet(this, _nextID), _this$nextID2 = _this$nextID++, _this$nextID)), _this$nextID2));\n      }\n      if (!(details && details[\'info\'])) return entity;\n      Object.keys(details[\'info\']).forEach(function (detail) {\n        if (details[\'info\'][detail] != undefined) {\n          entity[detail] = details[\'info\'][detail];\n        }\n      });\n\n      // Defensive output type check\n\n      if (!(entity instanceof _classPrivateFieldGet(this, _Entity))) {\n        console.error("Something went wrong when creating a new Entity of type ".concat(typeName));\n        return false;\n      }\n      return entity;\n    }\n  }, {\n    key: "getCollectionsOfType",\n    value: function getCollectionsOfType(typeName) {\n      if (!_classPrivateFieldGet(this, _types)[typeName]) {\n        console.warn("Cannot get collections from unexisting type \'".concat(typename, "\'"));\n        return false;\n      }\n      var collections = _classPrivateFieldGet(this, _types)[typeName].collections || [];\n      return collections;\n    }\n  }, {\n    key: "storeToBeRemoved",\n    value: function storeToBeRemoved(entity) {\n      this.toBeRemoved.push(entity);\n    }\n  }, {\n    key: "removeAgent",\n    value: function removeAgent(entity) {\n      var _this = this;\n      try {\n        var agentType = entity.getType();\n        var agentCollections = entity.getCollections();\n        agentCollections.forEach(function (collectionName) {\n          _this.world.removeFromCollection(collectionName, entity);\n        });\n        var agentChildren = Object.keys(entity._children);\n        while (agentChildren.length) {\n          this.removeAgent(entity._children[agentChildren[0]]);\n          delete entity._children[agentChildren[0]];\n          agentChildren.shift();\n        }\n        _classPrivateFieldGet(this, _pools)[agentType].push(entity);\n      } catch (err) {\n        console.error("Error removing entity ".concat(entity));\n        return false;\n      }\n    }\n  }, {\n    key: "removeAgents",\n    value: function removeAgents() {\n      while (this.toBeRemoved.length) {\n        var entity = this.toBeRemoved.pop();\n        this.removeAgent(entity);\n      }\n    }\n  }, {\n    key: "resetAgent",\n    value: function resetAgent(entity) {\n      var _this$nextID3, _this$nextID4;\n      var prototype = _classPrivateFieldGet(this, _types)[entity.getType()];\n      entity.reset(prototype, (_classPrivateFieldSet(this, _nextID, (_this$nextID3 = _classPrivateFieldGet(this, _nextID), _this$nextID4 = _this$nextID3++, _this$nextID3)), _this$nextID4));\n    }\n  }]);\n  return EntityPool;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EntityPool);\n\n//# sourceURL=webpack://cases/./src/EntityPool.js?')},"./src/EventManager.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nvar EventManager = /*#__PURE__*/function () {\n  function EventManager(world) {\n    _classCallCheck(this, EventManager);\n    this.world = world;\n    this.events = {};\n  }\n  _createClass(EventManager, [{\n    key: "registerEvent",\n    value: function registerEvent(eventName) {\n      if (this.events[eventName]) {\n        console.warn("Event named \'".concat(eventName, " has already been registered\'"));\n        return false;\n      }\n      this.events[eventName] = {};\n    }\n  }, {\n    key: "registerServiceToEvent",\n    value: function registerServiceToEvent(serviceName, eventName) {\n      if (!this.events[eventName]) {\n        console.warn("Cannot register service \'".concat(serviceName, "\' to unregistered event \'").concat(eventName, "\'"));\n        return false;\n      }\n      var service = this.world.getService(serviceName);\n      if (!service) {\n        console.warn("Cannot register service \'".concat(serviceName, "\' to event, because the service is not registered to the framework"));\n        return false;\n      }\n      if (typeof service["on".concat(eventName)] != \'function\') {\n        console.warn("Cannot register service \'".concat(serviceName, "\' to event, because the service does not have a method \'on").concat(eventName, "\'"));\n        return false;\n      }\n      this.events[eventName][serviceName] = service;\n    }\n  }, {\n    key: "notifyToServices",\n    value: function notifyToServices(eventName) {\n      var _this = this;\n      var details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      if (!this.events[eventName]) {\n        console.warn("Cannot notify event \'".concat(eventName, "\' because it does not exist"));\n        return false;\n      }\n      var services = Object.keys(this.events[eventName]);\n      services.forEach(function (serviceName) {\n        _this.world.getService(serviceName)["on".concat(eventName)](details);\n      });\n    }\n  }]);\n  return EventManager;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EventManager);\n\n//# sourceURL=webpack://cases/./src/EventManager.js?')},"./src/Service.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nvar Service = /*#__PURE__*/function () {\n  function Service() {\n    _classCallCheck(this, Service);\n    this.world = new World();\n  }\n  _createClass(Service, [{\n    key: "execute",\n    value: function execute() {\n      return false;\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      return false;\n    }\n  }]);\n  return Service;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Service);\n\n//# sourceURL=webpack://cases/./src/Service.js?')},"./src/ServiceManager.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }\nvar _services = /*#__PURE__*/new WeakMap();\nvar ServiceManager = /*#__PURE__*/function () {\n  function ServiceManager(world) {\n    _classCallCheck(this, ServiceManager);\n    _classPrivateFieldInitSpec(this, _services, {\n      writable: true,\n      value: void 0\n    });\n    this.world = world;\n    _classPrivateFieldSet(this, _services, {});\n  }\n  _createClass(ServiceManager, [{\n    key: "registerService",\n    value: function registerService(name, service) {\n      // Defensive input check\n\n      if (typeof name !== \'string\' || name == \'\') {\n        throw Error("Cannot register service with a name defined as: ".concat(typeName, "; the name must be a non-empty string"));\n        return false;\n      }\n      if (_classPrivateFieldGet(this, _services)[name]) {\n        throw Error("Service named \'".concat(name, "\' already registered"));\n        return false;\n      }\n      if (!service || service == null) {\n        throw Error("Cannot register invalid or null service \'".concat(name, "\'"));\n        return false;\n      }\n\n      //\n\n      service.world = this.world;\n      _classPrivateFieldGet(this, _services)[name] = service;\n      _classPrivateFieldGet(this, _services)[name].init();\n      return true;\n    }\n  }, {\n    key: "getServices",\n    value: function getServices() {\n      return _classPrivateFieldGet(this, _services);\n    }\n  }, {\n    key: "getService",\n    value: function getService(serviceName) {\n      if (!_classPrivateFieldGet(this, _services)[serviceName]) {\n        throw Error("Cannot get unregistered service \'".concat(serviceName, "\'"));\n        return false;\n      }\n      return _classPrivateFieldGet(this, _services)[serviceName];\n    }\n  }]);\n  return ServiceManager;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ServiceManager);\n\n//# sourceURL=webpack://cases/./src/ServiceManager.js?')},"./src/World.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _EntityPool_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EntityPool.js */ "./src/EntityPool.js");\n/* harmony import */ var _CollectionManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CollectionManager.js */ "./src/CollectionManager.js");\n/* harmony import */ var _EventManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventManager.js */ "./src/EventManager.js");\n/* harmony import */ var _Service_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Service.js */ "./src/Service.js");\n/* harmony import */ var _ServiceManager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ServiceManager.js */ "./src/ServiceManager.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }\n\n\n\n\n\nvar _entityPool = /*#__PURE__*/new WeakMap();\nvar _collectionManager = /*#__PURE__*/new WeakMap();\nvar _serviceManager = /*#__PURE__*/new WeakMap();\nvar _eventManager = /*#__PURE__*/new WeakMap();\nvar World = /*#__PURE__*/function () {\n  function World() {\n    _classCallCheck(this, World);\n    _classPrivateFieldInitSpec(this, _entityPool, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _collectionManager, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _serviceManager, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _eventManager, {\n      writable: true,\n      value: void 0\n    });\n    // subordinate modules\n\n    _classPrivateFieldSet(this, _entityPool, new _EntityPool_js__WEBPACK_IMPORTED_MODULE_0__["default"](this));\n    _classPrivateFieldSet(this, _collectionManager, new _CollectionManager_js__WEBPACK_IMPORTED_MODULE_1__["default"](this));\n    _classPrivateFieldSet(this, _eventManager, new _EventManager_js__WEBPACK_IMPORTED_MODULE_2__["default"](this));\n    _classPrivateFieldSet(this, _serviceManager, new _ServiceManager_js__WEBPACK_IMPORTED_MODULE_4__["default"](this));\n\n    //Iteration\n\n    this.frame = 0;\n    this.routine = function () {};\n    this.pause = false;\n  }\n  _createClass(World, [{\n    key: "registerService",\n    value: function registerService(name, service) {\n      return _classPrivateFieldGet(this, _serviceManager).registerService(name, service);\n    }\n  }, {\n    key: "getServices",\n    value: function getServices() {\n      return _classPrivateFieldGet(this, _serviceManager).getServices();\n    }\n  }, {\n    key: "getService",\n    value: function getService(serviceName) {\n      return _classPrivateFieldGet(this, _serviceManager).getService(serviceName);\n    }\n  }, {\n    key: "registerCollection",\n    value: function registerCollection(name) {\n      return _classPrivateFieldGet(this, _collectionManager).registerCollection(name);\n    }\n  }, {\n    key: "getCollection",\n    value: function getCollection(collectionName) {\n      return _classPrivateFieldGet(this, _collectionManager).getCollection(collectionName);\n    }\n  }, {\n    key: "addToCollection",\n    value: function addToCollection(collectionName, object) {\n      return _classPrivateFieldGet(this, _collectionManager).addToCollection(collectionName, object);\n    }\n  }, {\n    key: "removeFromCollection",\n    value: function removeFromCollection(collectionName, object) {\n      return _classPrivateFieldGet(this, _collectionManager).cacheToBeRemoved(collectionName, object);\n    }\n  }, {\n    key: "registerAgentType",\n    value: function registerAgentType(typeName, prototype) {\n      return _classPrivateFieldGet(this, _entityPool).registerType(typeName, prototype);\n    }\n  }, {\n    key: "createAgent",\n    value: function createAgent(typeName) {\n      var details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var entity = _classPrivateFieldGet(this, _entityPool).createAgent(typeName, details);\n\n      /*\n       let collections = this.#entityPool.getCollectionsOfType(typeName);\n       collections.forEach((collection) => {\n          this.addToCollection(collection, entity);\n      });\n       */\n\n      return entity;\n    }\n  }, {\n    key: "removeAgent",\n    value: function removeAgent(entity) {\n      _classPrivateFieldGet(this, _entityPool).storeToBeRemoved(entity);\n    }\n  }, {\n    key: "registerEvent",\n    value: function registerEvent(eventName) {\n      _classPrivateFieldGet(this, _eventManager).registerEvent(eventName);\n    }\n  }, {\n    key: "registerServiceToEvent",\n    value: function registerServiceToEvent(serviceName, eventName) {\n      _classPrivateFieldGet(this, _eventManager).registerServiceToEvent(serviceName, eventName);\n    }\n  }, {\n    key: "notifyEvent",\n    value: function notifyEvent(eventName, details) {\n      _classPrivateFieldGet(this, _eventManager).notifyToServices(eventName, details);\n    }\n  }, {\n    key: "execute",\n    value: function execute() {\n      var _this = this;\n      if (this.pause) {\n        return;\n      }\n      requestAnimationFrame(function () {\n        _this.execute();\n      });\n      _classPrivateFieldGet(this, _entityPool).removeAgents();\n      _classPrivateFieldGet(this, _collectionManager).removeAgentsFromCollections();\n      var services = this.getServices();\n      Object.keys(services).forEach(function (service) {\n        services[service].execute();\n      });\n      if (!this.pause) {\n        this.frame++;\n        this.routine(this);\n      }\n    }\n  }, {\n    key: "pauseExecution",\n    value: function pauseExecution() {\n      this.pause = true;\n    }\n  }]);\n  return World;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (World);\n\n//# sourceURL=webpack://cases/./src/World.js?')}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var r=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](r,r.exports,__webpack_require__),r.exports}__webpack_require__.d=(e,t)=>{for(var r in t)__webpack_require__.o(t,r)&&!__webpack_require__.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/World.js")})();